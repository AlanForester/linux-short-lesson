##Производительность системы

####Основные утилиты мониторинга производительности системы (sysstat: top, iostat, vmstat) и отдельных процессов (ps, strace).

В этом уроке мы рассмотрим инструменты, с помощью которых можно проанализировать загруженность четырёх основных 
подсистем сервера: памяти, процессора, дисковой и сетевой подсистемы.

Утилита общего сбора статичтики ```vmstat``` показывает метрики использования CPU IO SWAP MEM вместе.
```shell script
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 2278220 676440 4765668    0    0     2    25   26    9  2  0 98  0  0
```
В первую очередь стоит обратить внимание us, id, wa
```shell script
us              - загрузка пользовательскими процессами. Если ваш сервер постоянно не загружен ресурсоёмкими операциями, типа конвертации файлов, то этот показатель не должен превышать 10-20%.
id              - процент времени бездействия процессора, должен быть высоким, в норме - от 80.
wa              - ожидание операций ввода/вывода, чем ниже, тем лучше (иначе процессор слишком долго ждёт ответы от диска или сети).
```
В выводе данной команды нас также интересуют 2 значения: free и swpd. 
Первое из них показывает, сколько оперативной памяти сейчас свободно. Стабильно низкий объём свободной памяти сам по 
себе не говорит о каких-то проблемах, но за ним стоит начать следить, чтобы убедиться, что памяти будет хватать даже 
при пиковых нагрузках. Важно обратить внимание на использование файла подкачки (swpd). Если оно больше нуля, значит 
часть данных не помещается в оперативную память и вытесняется на диск, а так как дисковые операции чтения и записи 
гораздо медленнее аналогичных для памяти, то падает производительность всей системы, а значит следует мониторить IO 
подсистему.

#### Диагностика использование процессора
Поиск проблемных мест стоит начать с использования команды ```top```. Вывод будет примерно следующим:
~~~shell script
top - 02:01:22 up 5 days, 14:14,  1 user,  load average: 0.00, 0.05, 0.07
Tasks: 141 total,   1 running,  92 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8150204 total,  2333436 free,   390764 used,  5426004 buff/cache
KiB Swap:  1003516 total,  1003516 free,        0 used.  7435640 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    
14499 root      20   0   44076   4116   3512 R   0.7  0.1   0:00.06 top        
  911 redis     20   0   51444   4272   3004 S   0.3  0.1   7:56.66 redis-serv+
    1 root      20   0  160236   9576   6764 S   0.0  0.1   1:12.11 systemd    
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.08 kthreadd   
    4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:+
~~~

Обратите внимание на следующие показатели
```shell script
load avegare    - состоит из трёх чисел и показывает усреднённую загрузку сервера за 1, 5 и 15 минут. Чем ниже значения,тем лучше. Эта характеристика не является точной, но позволяет быстро оценить, насколько загружен процессор. Значения не должны быть больше количества процессоров.
%CPU            - процессорных ресурсов потребляет процесс в строке
```

Также существует полезная утилита ```atop```  В отличие от top, выводит только новые изменения об активных системных 
процессах. Позволяет контролировать нагрузку процессора, памяти, накопителя, сети, а также просматривать распределение 
нагрузок по работающим процессам. В Ubuntu и Debian запускается автоматически и постоянно записывает информацию о 
процессах в /var/log/atop.log.

#### Sysstat
Установить и запустить sysstat можно следующей командой
~~~shell script
apt install -y sysstat
systemctl start sysstat 
~~~

Sysstat включает в себя следующие утилиты

~~~
sar         — утилита для просмотра системных характеристик, логирование осуществляется с помощью бэкенда sadc
sadf        — генерирует отчеты sar в формате CSV или XML
iostat      — статистика ввода/вывода
mpstat      — статистика CPU
pidstat     — статистика по PID процесса
nfsiostat   — статистика NFS
cifsiostat  — статистика CIFS
~~~

Примеры использования sysstat утилит, смотрите в файле sysstat.sh

#### Использование оперативной памяти
Использование памяти можно посмотреть с помощью утилиты free (установлена по умолчанию). Чтобы числа были более 
человекочитаемыми, используйте ключ -h. Введите ```free -h```
~~~shell script
              total        used        free      shared  buff/cache   available
Mem:           7.8G        412M        2.2G         19M        5.2G        7.1G
Swap:          979M          0B        979M
~~~
Как видно, на сервере у нас имеется 7.8G памяти, из них в настоящий момент используются 412M, 2.2G Мб свободно, 
5.2G заняты под буферы и кэши и 7.1G доступно.

Ту же информацию с некоторыми подробностями можно получить введя команду ```cat /proc/meminfo```

#### Дисковая подсистема
Первым делом следует проверить наличие свободного места. Это можно сделать с помощью команды df. Как и в случае с free, 
используйте ключ -h для приведения чисел к нормализованному виду ```dh -h```
~~~shell script
udev                        3.9G     0  3.9G   0% /dev
tmpfs                       796M  2.8M  794M   1% /run
/dev/mapper/codev--vg-root  109G   13G   90G  13% /
tmpfs                       3.9G     0  3.9G   0% /dev/shm
tmpfs                       5.0M  4.0K  5.0M   1% /run/lock
tmpfs                       3.9G     0  3.9G   0% /sys/fs/cgroup
/dev/loop1                   98M   98M     0 100% /snap/core/9993
/dev/loop0                   97M   97M     0 100% /snap/core/9804
/dev/sda1                   511M  4.0M  508M   1% /boot/efi
tmpfs                       796M     0  796M   0% /run/user/0
~~~

Старайтесь всегда иметь достаточно свободного места (Avail) на используемых разделах.
Дисковая подсистема может создавать задержки даже при достаточном объёме свободного места, если объём одновременно 
читаемой или записываемой информации превосходит пропускную способность диска. Это можно определить с помощью утилиты 
```iotop```

Интересующие нас показатели: Actual DISK READ и Actual DISK WRITE. Если значения высоки (десятки и сотни M/s), 
то обратите внимание в таблице на процессы, которые производят наибольшую нагрузку и проанализируйте, почему это 
происходит и как нагрузку можно снизить (кеширование, отключение лишних логов, настройка базы данных и т.д.).

#### Сеть

##### Nload
Недостаточность пропускной способности сети довольно редко является причиной увеличения времени отклика от сервера, 
однако случается и такое. Чтобы посмотреть объёмы сетевого трафика в реальном времени, можно использовать простейшую 
утилиту ```nload```.

##### Iftop
У вас может возникнуть потребность узнать IP-адреса устройств, обменивающихся трафиком с вашим сервером. 
Это можно сделать, например, с помощью утилиты ```iftop```
```shell script
                               12.5Kb                         25.0Kb                         37.5Kb                         50.0Kb                   62.5Kb
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
10.0.1.2                                                        => 10.0.1.50                                                        3.38Kb  2.89Kb  3.88Kb
                                                                <=                                                                   208b    258b   1.04Kb
10.0.1.2                                                        => 122.224.217.42                                                      0b   1.76Kb   451b
                                                                <=                                                                     0b   1.05Kb   269b
10.0.1.2                                                        => dns.google                                                        532b    601b    236b
                                                                <=                                                                   648b    498b    260b
10.0.1.2                                                        => static.228.98.9.176.clients.your-server.de                        208b     83b     62b
Total 22.5Kb  15.7Kb  15.7Kb
```

Если среднее значение Total близко к пропускной способности сетевого интерфейса сервера (например 100Мбит/c). 
То вероятно, пора либо бороться с DDoS-атакой, или планировать масштабирование.

##### Ping
Иногда бывает неисправность сетевого интерфейса, или потеря пакетов. Потерю можно определить с помощью команды ```ping```

Не резолвить имена адресов, выводить только ip-адреса 
```
ping -n servers.ru
```
Завершение работы ping по заданному времени (тут 5 секунд)
```
ping -w 5 servers.ru
```
Установить размер отправляемых пакетов в 1000 байт 
```
ping -s 1000 servers.ru
```

Увеличить интервал времени пинга на 3 секунды
```
ping -i 3 neoserver.ru
```

##### MTR
Объединяя функции ping и traceroute, mtr позволяет постоянно опрашивать удаленный сервер и отслеживать изменения 
задержки и производительности с течением времени.

```
mtr servers.ru
```
##### Nethogs
```nethogs``` отображает сетевой трафик от конкретных приложений.
```shell script
    PID USER     PROGRAM                                                                                               DEV        SENT      RECEIVED       
   9922 root     sshd: root@pts/1                                                                                      enp1s0      0.910       0.535 KB/sec
   1134 debian.. /usr/bin/tor                                                                                          enp1s0      0.013       0.119 KB/sec
      ? root     unknown TCP                                                                                                       0.000       0.000 KB/sec
```
#####
Монитор ```iptstate```, показывает активные соединения с возможностью их оборвать. 
[Go back](https://github.com/AlexCollin/linux-short-lesson)